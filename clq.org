#+TITLE: The =clq= interpreter

* General comments

- We will build an interpreter called =clq= that supports gates and measurements
- All quantum gates are transmuted into a single linear operator that acts on
the Hilbert space of the wave function
- The language will have a Lisp-like syntax, and will use Common Lisp array syntax

* Code

Our programming language will be model by an abstract machine of \(n\) qubits \(M_n\),
whose state will be given by a quantum state \(v\) and a \(n\)-bit measurement register.
We can consider that \(v \in \mathcal{C}^{2^n}\).

#+begin_src lisp :tangle yes
  (defstruct machine
    quantum-state
    measurement-register)
#+end_src

#+RESULTS:
: MACHINE

The remaining discussion assumes a basic quantum mechanics background. Let's define a \(n\)
qubit quantum state:

#+begin_src lisp :tangle yes
  (defun make-quantum-state (n)
    (let ((s (make-array (expt 2 n) :initial-element 0.0d0)))
      (setf (aref s 0) 1.0d0)
      s))
#+end_src

#+RESULTS:
: MAKE-QUANTUM-STATE

The above function will return the ket \(|00 \ldots 0\rangle\). It has a coefficient of one,
indicating that this is the only contribution to the initial state. Next, we define a function
to retrieve the number of qubits for a given Hilbert space size. This amounts to compute
the binary logarithm (number of bits in binary representation):

#+begin_src lisp :tangle yes
  (defun dimension-qubits (d)
    (- (integer-length d) 1))
#+end_src

#+RESULTS:
: DIMENSION-QUBITS

The propagation of the quantum system is then implemented using linear algebra operations:

#+begin_src lisp :tangle yes
  (defun apply-operator (unitary-operator ket)
    (let* ((oper-size (array-dimension unitary-operator 0))
  	 (new-ket (make-array oper-size :initial-element 0.0d0)))
      (dotimes (i oper-size)
        (let ((element 0.0d0))
  	(dotimes (j oper-size)
  	  (incf element (* (aref unitary-operator i j) (aref ket j))))
  	(setf (aref new-ket i) element)))
      (replace ket new-ket)))
#+end_src

#+RESULTS:
: APPLY-OPERATOR

#+begin_src lisp :tangle yes
  (defun compose-operator (unitary-left unitary-right)
    (let* ((m (array-dimension unitary-left 0))
  	 (n (array-dimension unitary-left 1))
  	 (p (array-dimension unitary-right 1))
  	 (unitary-new (make-array (list m p) :initial-element 0.0d0)))
      (dotimes (i m unitary-new)
        (dotimes (j p)
  	(let ((dot-prod 0.0d0))
  	  (dotimes (k n)
  	    (setf dot-prod (+ dot-prod
  			      (* (aref unitary-left i k)
  				 (aref unitary-right k j)))))
  	  (setf (aref unitary-new i j) dot-prod))))))
#+end_src

#+RESULTS:
: COMPOSE-OPERATOR

Provided the linear algebra machinery, we proceed to implement measurements. Again, domain knowledge
is needed here, in particular regarding the collapse of the wave function.

#+begin_src lisp :tangle yes
  (defun observe (machine)
    (let ((b (sample (machine-quantum-state machine))))
      (collapse (machine-quantum-state machine) b)
      (setf (machine-measurement-register machine) b)
      machine))
#+end_src

#+RESULTS:
: OBSERVE

In the code above the wave function is collapsed and saved in the register using the automatically
generated accessor of =machine=. The next section is more interesting, as it deals with the sampling
process. In statistical terms, we want to do is to sample a discrete random variable whose CDF is:

\begin{equation}
  F(q_j) = \sum_{i \le j}p(q_i)
\end{equation}

If we have \(U = \text{Uniform}(0, 1)\) then we can leverage this to sample:

\begin{equation}
  \text{Pr}(U \in (F(q_{j-1}), F(q_{j})]) = \text{Pr}(F(q_{j-1}) < U \le F(q_{j})) = F(q_{j}) - F(q_{j-1}) = p(q_{j})
\end{equation}

We can implement the above equations as follows:

#+begin_src lisp :tangle yes
  (defun sample (state)
    (let ((u (random 1.0d0)))
      (dotimes (i (length state))
        (decf u (expt (abs (aref state i)) 2))
        (when (minusp u) (return i)))))
#+end_src

#+RESULTS:
: SAMPLE

The collapse of the wave function implies this realization:

#+begin_src lisp :tangle yes
  (defun collapse (state qubit)
    (fill state 0.0d0)
    (setf (aref state qubit) 1.0d0))
#+end_src

#+RESULTS:
: COLLAPSE

Now we can proceed to define some gates. Let's start with the identity:

#+begin_src lisp :tangle yes
  (defparameter +I+ #2A((1 0)
  		      (0 1))
  	      "The identity gate.")
#+end_src

#+RESULTS:
: +I+

Then a function to apply a generic gate:

#+begin_src lisp :tangle yes
  (defun apply-gate (state unitary-operator qubits)
    (assert (= (length qubits)
  	     (dimension-qubits (array-dimension unitary-operator 0))))
    (if (= (length qubits) 1)
        (apply-singleq-gate state unitary-operator (first qubits))
        (apply-multiq-gate state unitary-operator qubits)))
#+end_src

#+RESULTS:
: APPLY-GATE

We need an implementation of the Kronecker product for generating multi-qubit gates:

#+begin_src lisp :tangle yes
  (defun kronecker-product (unitary-A unitary-B)
    (destructuring-bind (m n) (array-dimensions unitary-A)
      (destructuring-bind (p q) (array-dimensions unitary-B)
        (let ((kron-dot-unitary (make-array (list (* m p) (* n q)))))
  	(dotimes (i m kron-dot-unitary)
  	  (dotimes (j n)
  	    (let ((unitary-A-ij (aref unitary-A i j))
  		  (pointer-row (* i p))
  		  (pointer-col (* j q)))
  	      (dotimes (k p)
  		(dotimes (l q)
  		  (setf (aref kron-dot-unitary
  			      (+ pointer-row k) (+ pointer-col l))
  			(* unitary-A-ij (aref unitary-B k l))))))))))))
#+end_src

#+RESULTS:
: KRONECKER-PRODUCT

The discussion then focus on using the Kronecker product to generate the action of a
gate \(g\) on a qubit \(i\), or in a continuous range of qubits. This can be achieved with
the following lift operator:

\begin{equation}
 \text{lift}(g, i, n) = \mathcal{I} \otimes \ldots \otimes \mathcal{I} \otimes g \otimes \ldots \mathcal{I}
\end{equation}

where the first \(ldots\) covers \(n - i - 3\) factors and the second one \(i - 1\) factors.

#+begin_src lisp :tangle yes
  (defun kronecker-expt (unitary n)
    (cond
      ((< n 1) #2A((1)))
      ((= n 1) unitary)
      (t (kronecker-product (kronecker-expt unitary (- n 1)) unitary))))
#+end_src

#+RESULTS:
: KRONECKER-EXPT

With the above definition, the lift operator can be implemented as:

#+begin_src lisp :tangle yes
  (defun lift (unitary i n)
    (let ((left-factors (kronecker-expt +I+ (- n i (dimension-qubits
  						  (array-dimension unitary 0)))))
  	(right-factors (kronecker-expt +I+ i)))
      (kronecker-product left-factors
  		       (kronecker-product unitary right-factors))))
#+end_src

#+RESULTS:
: LIFT

Note that the above function accounts for multiple adjacent qubit gates. Multiple non-adjacent
qubit gates' actions are a bit trickier to handle. The idea is to generate a permutation matrix
\(\Pi\) that will set the qubit temporarily adjacent, apply the gate, and restores the initial order:

\begin{equation}
 \Pi^{-1}\text{lift}(g, 0, n)\Pi
\end{equation}

We then define the *SWAP* gate (or Fredkin gate), which exchanges the states of two qubits:

#+begin_src lisp :tangle yes
  (defparameter +SWAP+ #2A((1 0 0 0)
  			 (0 0 1 0)
  			 (0 1 0 0)
  			 (0 0 0 1)))
#+end_src

#+RESULTS:
: +SWAP+

Using the fact that permutations can be decomposed into product of adjacent transpositions, we
can form a list of cons cells with the required transpositions as follows:

#+begin_src lisp :tangle yes
  (defun perm-as-trans (permutation)
    (let ((transpositions nil))
      (dotimes (natural (length permutation) (nreverse transpositions))
        (let ((permuted (elt permutation natural)))
  	(loop :while (< permuted natural) :do
  	  (setf permuted (elt permutation permuted)))
  	(when (> permuted natural)
  	  (push (cons natural permuted) transpositions))))))
#+end_src

#+RESULTS:
: PERM-AS-TRANS

Please note that in the above code the =permutation= indicates the index on the rearranged
array, not the rearranged array itself. This is in correspondence with Cauchy's two line
notation. The code above is tricky at times. Here is what it is doing:

1. We loop through the =natural= order of the set
2. For each target =permuted= index in =permutation=, if the index is larger than in the =natural=
   case we directly add a transposition. If it is smaller, we trace back the swaps needed to place
   index. This will eventually lead to a cycle (=permuted= equal =natural=) or a new transposition
   (=permuted= greater than =natural=)
3. The original code in the tutorial used a =cond= clause to avoid pushing to =transpositions=
   when no swap was needed. I streamlined this with a =when=

The next step is to cast the above transpositions as transpositions of adjacent qubits,
this time using a nice lambda:

#+begin_src lisp :tangle yes
  (defun trans-as-adjacent (transpositions)
    (mapcan (lambda (trans)
              (let ((start (car trans))
                    (end (cdr trans)))
                (if (= end (1+ start))
                    (list start)
                    (nconc (loop :for i :from start :below (1- end) :collect i)
  			 (loop :for i :from (1- end) :downto start :collect i)))))
            transpositions))
#+end_src

#+RESULTS:
: TRANS-AS-ADJACENT

Given all this procedures, we can write the core of the interpreter, which uses transpositions
to implement two qubit gates:

#+begin_src lisp :tangle yes
  (defun apply-singleq-gate (state unitary q)
    (apply-operator (lift unitary q (dimension-qubits (length state)))
                    state))

  (defun apply-multiq-gate (state unitary qubits)
    (let ((n (dimension-qubits (length state))))
      (labels ((trans-to-op (trans)
                 (reduce #'compose-operator trans
  		       :key (lambda (i) (lift +swap+ i n)))))
        (let* ((unitary-init (lift unitary 0 n))
               (perm (append (reverse qubits)
  			   (remove-if (lambda (i) (member i qubits))
                                        (loop for i :below n :collect i))))
               (trans (trans-as-adjacent (perm-as-trans perm)))
               (to->from (trans-to-op trans))
               (from->to (trans-to-op (reverse trans)))
               (unitary-conform (compose-operator to->from
  						(compose-operator unitary-init
  								  from->to))))
          (apply-operator unitary-conform state)))))
#+end_src

#+RESULTS:
: APPLY-MULTIQ-GATE

We can put then everything together in the driving loop of the interpreter:

#+begin_src lisp :tangle yes
  (defun clq (qprog machine)
    (loop :for (instruction . parameters) :in qprog
          :do (ecase instruction
                ((GATE)
                 (destructuring-bind (gate &rest qubits) parameters
                   (apply-gate (machine-quantum-state machine) gate qubits)))
                ((MEASURE)
                 (observe machine)))
          :finally (return machine)))
#+end_src

#+RESULTS:
: CLQ

* Example applications

** Bell states

Some additional gates:

#+begin_src lisp :tangle yes
  (defparameter +H+
    (make-array '(2 2)
  	      :initial-contents
  	      (let ((s (/ (sqrt 2))))
                  (list (list s s)
  		      (list s (- s))))))

  (defparameter +CNOT+ #2A((1 0 0 0)
                           (0 1 0 0)
                           (0 0 0 1)
                           (0 0 1 0)))

  (defparameter +X+ #2A((0 1)
  		      (1 0)))
#+end_src

#+RESULTS:
: +X+

And now this nice macro:

#+begin_src lisp :tangle yes
  (defun bell-state (p q)
    `((GATE ,+H+ ,p)
      (GATE ,+CNOT+ ,p ,q)))
#+end_src

#+RESULTS:
: BELL-STATE

Then the climax:

#+begin_src lisp :tangle yes
  (clq (bell-state 0 1)
       (make-machine :quantum-state (make-quantum-state 2)
                     :measurement-register 0))
#+end_src

#+RESULTS:
: #S(MACHINE
:    :QUANTUM-STATE #(0.7071067690849304d0 0.0d0 0.0d0 0.7071067690849304d0)
:    :MEASUREMENT-REGISTER 0)


** Quantum Fourier transform

First we add the phase \(R_k\) gate:

#+begin_src lisp :tangle yes
  (defun cphase (angle)
    (make-array '(4 4) :initial-contents `((1 0 0 0)
                                           (0 1 0 0)
                                           (0 0 1 0)
                                           (0 0 0 ,(cis angle)))))

  (defun cphase-reorder (angle)
    (make-array '(4 4) :initial-contents `((1 0 0 0)
                                           (0 ,(cis angle) 0 0)
                                           (0 0 1 0)
                                           (0 0 0 1))))
#+end_src

#+RESULTS:
: CPHASE-REORDER

And then the nice recursive procedure computing the QFT:

#+begin_src lisp :tangle yes
  (defun qft (qubits)
    (labels ((bit-reversal (qubits)
               (let ((n (length qubits)))
                 (if (< n 2)
                     nil
                     (loop :repeat (floor n 2)
                           :for qs :in qubits
                           :for qe :in (reverse qubits)
                           :collect `(GATE ,+swap+ ,qs ,qe)))))
             (%qft (qubits)
               (destructuring-bind (q . qs) qubits
                 (if (null qs)
                     (list `(GATE ,+H+ ,q))
                     (let ((cR (loop :with n := (1+ (length qs))
                                     :for i :from 1
                                     :for qi :in qs
                                     :for angle := (/ pi (expt 2 (- n i)))
                                     :collect `(GATE ,(cphase angle) ,q ,qi))))
                       (append
                        (qft qs)
                        cR
                        (list `(GATE ,+H+ ,q))))))))
      (append (%qft qubits) (bit-reversal qubits))))
#+end_src

#+RESULTS:
: QFT

Test what the heck that is doing:

#+begin_src lisp :tangle yes
  (qft '(0 1 2))
#+end_src

#+RESULTS:
#+begin_example
((GATE #2A((0.70710677 0.70710677) (0.70710677 -0.70710677)) 2)
 (GATE
  #2A((1 0 0 0) (0 1 0 0) (0 0 1 0) (0 0 0 #C(6.123233995736766d-17 1.0d0))) 1
  2)
 (GATE #2A((0.70710677 0.70710677) (0.70710677 -0.70710677)) 1)
 (GATE #2A((1 0 0 0) (0 0 1 0) (0 1 0 0) (0 0 0 1)) 1 2)
 (GATE
  #2A((1 0 0 0)
      (0 1 0 0)
      (0 0 1 0)
      (0 0 0 #C(0.7071067811865476d0 0.7071067811865475d0)))
  0 1)
 (GATE
  #2A((1 0 0 0) (0 1 0 0) (0 0 1 0) (0 0 0 #C(6.123233995736766d-17 1.0d0))) 0
  2)
 (GATE #2A((0.70710677 0.70710677) (0.70710677 -0.70710677)) 0)
 (GATE #2A((1 0 0 0) (0 0 1 0) (0 1 0 0) (0 0 0 1)) 0 2))
#+end_example

#+begin_src lisp :tangle yes
  (clq (qft '(0 1 2))
       (make-machine :quantum-state (make-quantum-state 3)
                     :measurement-register 0))
#+end_src

#+RESULTS:
#+begin_example
#S(MACHINE
   :QUANTUM-STATE #(#C(0.3535533724408484d0 0.0d0)
                    #C(0.3535533724408484d0 0.0d0)
                    #C(0.3535533724408484d0 0.0d0)
                    #C(0.3535533724408484d0 0.0d0)
                    #C(0.3535533724408484d0 0.0d0)
                    #C(0.3535533724408484d0 0.0d0)
                    #C(0.3535533724408484d0 0.0d0)
                    #C(0.3535533724408484d0 0.0d0))
   :MEASUREMENT-REGISTER 0)
#+end_example

** Quantum subroutine of Shor's algorithm

Let's define the period finding circuit of 15 with a "random" choice of \(a=11\):

#+begin_src lisp :tangle yes
  (defun shor-fifteen ()
    `((GATE ,+H+ 0)
      (GATE ,+H+ 1)
      (GATE ,+H+ 2)
      (GATE ,+CNOT+ 2 3)
      (GATE ,+CNOT+ 2 4)
      (GATE ,+H+ 1)
      (GATE ,(cphase-reorder (/ pi 2)) 0 1)
      (GATE ,+H+ 0)
      (GATE ,(cphase (/ pi 4)) 1 2)
      (GATE ,(cphase (/ pi 2)) 0 2)
      (GATE ,+H+ 2)
      (MEASURE)))
#+end_src

#+RESULTS:
: SHOR-FIFTEEN

Hopefully we find a period of 4 somewhere:

#+begin_src lisp :tangle yes
  (clq (shor-fifteen)
       (make-machine :quantum-state (make-quantum-state 5)
                     :measurement-register 0))
#+end_src


#+RESULTS:
: #S(MACHINE
:    :QUANTUM-STATE #(0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0
:                     0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0
:                     0.0d0 0.0d0 0.0d0 0.0d0 1.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0
:                     0.0d0 0.0d0)
:    :MEASUREMENT-REGISTER 24)

#+begin_src lisp :tangle yes
  (defun counts (realizations qubits)
    (let* ((hilbert (expt 2 qubits))
           (results (make-array hilbert :initial-element 0)))
      (dotimes (i realizations results)
        (let ((state (machine-quantum-state
                      (clq (shor-fifteen)
                           (make-machine :quantum-state (make-quantum-state qubits)
                                         :measurement-register 0)))))
  	(dotimes (j hilbert)
  	  (when (> (aref state j) 0) (incf (aref results j))))))))
  (counts 5 5)
#+end_src

#+RESULTS:
| 1 | 0 | 0 | 0 | 2 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 2 | 0 | 0 | 0 |

** Another version of Shor's subroutine for 15 (incomplete)

This is the full circuit for \(N=15\) and base \(a=11\), taken from this reference [[https://arxiv.org/abs/2306.09122][2306.09122]]. The circuit will have \(m=9\)
qubits in the control register and \(n=4\) qubits in the work register (length of 15's binary representation). We will manually
build the modular exponentiation gates of the quantum phase estimation part, and define the inverse QFT:

#+begin_src lisp :tangle yes
  (defun quantum-modular-exponentiation (exponent n-control)
    (let ((me-gates nil))
      (loop :repeat (expt 2 exponent) :do
        (push `(GATE ,+SWAP+ ,(+ n-control 1) ,(+ n-control 3)) me-gates)
        (push `(GATE ,+SWAP+ ,(+ n-control 0) ,(+ n-control 2)) me-gates))
      (nreverse me-gates)))
  (quantum-modular-exponentiation 1 9)
#+end_src

#+RESULTS:
| 1.0d0 | 0.0d0 | 0.0d0 | 0.0d0 | 0.0d0 | 0.0d0 | 0.0d0 | 0.0d0 | 0.0d0 | 0.0d0 | 0.0d0 | 0.0d0 | 0.0d0 | 0.0d0 | 0.0d0 | 0.0d0 |

#+begin_src lisp :tangle yes
  (defun qft-dagger (n)
    (let ((gates nil))
      ;; Perform bit reversal by swapping qubits.
      (loop :for q :from 0 :below (floor n 2) :do
            (push `(GATE ,+swap+ ,q ,(- n q 1)) gates))
      ;; Apply the controlled phase gates and Hadamard gates.
      (loop :for j :from 0 :below n :do
            (progn
              (loop :for m :from 0 :below j :do
                    (push `(GATE ,(cphase (- (/ pi (expt 2 (1+ (- j m)))))) ,m ,j) gates))
              (push `(GATE ,+H+ ,j) gates)))
      (nreverse gates)))
  (qft-dagger 3)
#+end_src

#+RESULTS:
#+begin_example
((GATE #2A((1 0 0 0) (0 0 1 0) (0 1 0 0) (0 0 0 1)) 0 2)
 (GATE #2A((0.70710677 0.70710677) (0.70710677 -0.70710677)) 0)
 (GATE
  #2A((1 0 0 0)
      (0 1 0 0)
      (0 0 1 0)
      (0 0 0 #C(0.7071067811865476d0 -0.7071067811865475d0)))
  0 1)
 (GATE #2A((0.70710677 0.70710677) (0.70710677 -0.70710677)) 1)
 (GATE
  #2A((1 0 0 0)
      (0 1 0 0)
      (0 0 1 0)
      (0 0 0 #C(0.9238795325112867d0 -0.3826834323650898d0)))
  0 2)
 (GATE
  #2A((1 0 0 0)
      (0 1 0 0)
      (0 0 1 0)
      (0 0 0 #C(0.7071067811865476d0 -0.7071067811865475d0)))
  1 2)
 (GATE #2A((0.70710677 0.70710677) (0.70710677 -0.70710677)) 2))
#+end_example

The full circuit is then:

#+begin_src lisp :tangle yes
  (defun shor-fifteen-full (n m)
    (let ((circuit nil))
      ;;  Initialize control qubits
      (loop :for q-control :bellow m :do
        (push `(GATE ,+H+ ,q-control) circuit))
      ;; Populate work register with state |1>
      (push `(GATE ,+X+ ,(+ m 1)) circuit)
      ;; Modular exponentiation
      ;; Inverse quantum Fourier transform
      (push (qft-dagger m) circuit)
      ;;  Correct the order of execution after pushing
      (nreverse circuit)))
#+end_src

#+RESULTS:
: SHOR-FIFTEEN-FULL

The challenge in this implementation is the factorization of the controlled U gates, which is quite complicated
in an interpreter like =clq=.

** Factorizing 21 with Shor's algorithm

We will follow for this example the circuit proposed in [[https://arxiv.org/pdf/2103.13855.pdf][2103.13855]]. This is a much more simpler circuit than the one
attempted in the previous section, it is in fact a compiled version of the full one. We will use the base \(a=4\).
We start by defining the Toffoli gate (controlled-controlled-not):

#+begin_src lisp :tangle yes
  (defun make-toffoli-gate ()
    (let ((matrix (make-array '(8 8)
  			    :element-type 'double-float
  			    :initial-element 0.0d0)))
      ;; Setting diagonal elements to 1 for no-op cases
      (dotimes (i 8)
        (setf (aref matrix i i) 1d0))
      ;; Swap the elements for the |110> and |111> states
      (setf (aref matrix 6 6) 0.0d0)
      (setf (aref matrix 6 7) 1.0d0)
      (setf (aref matrix 7 7) 0.0d0)
      (setf (aref matrix 7 6) 1.0d0)
      matrix))

  ;; To use this function
  (defparameter +TOFFOLI+ (make-toffoli-gate))
#+end_src

#+RESULTS:
: +TOFFOLI+

The important part here is that after compilation, the quantum subroutine of the circuit evaluates \(\log_4 [4^x \% 21]\).
By using a suitable mapping, we are left with 3 qubits in the control register and 2 in the work register. The controlled
gates \(U_a^x\) for \(x \in [2^0, 2^1, 2^2]\) are then factorized in terms of CNOTs and TOFFOLIs.

#+begin_src lisp :tangle yes
  (defun shor-21 (r-control r-work)
    (let ((circuit nil)
  	(n-qubits (+ r-control r-work)))
      ;;  Initialize control qubits
      (loop :for c :below r-control :do
        (push `(GATE ,+H+ ,c) circuit))
      ;; Populate work register with state |1>
      (push `(GATE ,+X+ ,r-control) circuit)
      ;; Compiled modular exponentiation U^1
      (push `(GATE ,+CNOT+ ,(- r-control 1) ,(- n-qubits 1)) circuit)
      ;; Compiled modular exponentiation U^2
      (push `(GATE ,+CNOT+ ,(- r-control 2) ,(- n-qubits 1)) circuit)
      (push `(GATE ,+CNOT+ ,(- n-qubits 1) ,(- n-qubits 2)) circuit)
      (push `(GATE ,+TOFFOLI+ ,(- r-control 2) ,(- n-qubits 2) ,(- n-qubits 1)) circuit)
      (push `(GATE ,+CNOT+ ,(- n-qubits 1) ,(- n-qubits 2)) circuit)
      ;; Compiled modular exponentiation U^4
      (push `(GATE ,+X+ ,(- n-qubits 1)) circuit)
      (push `(GATE ,+TOFFOLI+ ,0 ,(- n-qubits 1) ,(- n-qubits 2)) circuit)
      (push `(GATE ,+X+ ,(- n-qubits 1)) circuit)
      (push `(GATE ,+CNOT+ ,(- n-qubits 1) ,(- n-qubits 2)) circuit)
      (push `(GATE ,+TOFFOLI+ ,0 ,(- n-qubits 2) ,(- n-qubits 1)) circuit)
      (push `(GATE ,+CNOT+ ,(- n-qubits 1) ,(- n-qubits 2)) circuit)
      ;; Inverse quantum Fourier transform
      (setf circuit (nconc (nreverse circuit) (qft-dagger r-control)))
      ;;  Correct the order of execution after pushing
      circuit))
  (shor-21 3 2)
#+end_src

#+RESULTS:
#+begin_example
((GATE #2A((0.70710677 0.70710677) (0.70710677 -0.70710677)) 0)
 (GATE #2A((0.70710677 0.70710677) (0.70710677 -0.70710677)) 1)
 (GATE #2A((0.70710677 0.70710677) (0.70710677 -0.70710677)) 2)
 (GATE #2A((0 1) (1 0)) 3)
 (GATE #2A((1 0 0 0) (0 1 0 0) (0 0 0 1) (0 0 1 0)) 2 4)
 (GATE #2A((1 0 0 0) (0 1 0 0) (0 0 0 1) (0 0 1 0)) 1 4)
 (GATE #2A((1 0 0 0) (0 1 0 0) (0 0 0 1) (0 0 1 0)) 4 3)
 (GATE
  #2A((1.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0)
      (0.0d0 1.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0)
      (0.0d0 0.0d0 1.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0)
      (0.0d0 0.0d0 0.0d0 1.0d0 0.0d0 0.0d0 0.0d0 0.0d0)
      (0.0d0 0.0d0 0.0d0 0.0d0 1.0d0 0.0d0 0.0d0 0.0d0)
      (0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 1.0d0 0.0d0 0.0d0)
      (0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 1.0d0)
      (0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 1.0d0 0.0d0))
  1 3 4)
 (GATE #2A((1 0 0 0) (0 1 0 0) (0 0 0 1) (0 0 1 0)) 4 3)
 (GATE #2A((0 1) (1 0)) 4)
 (GATE
  #2A((1.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0)
      (0.0d0 1.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0)
      (0.0d0 0.0d0 1.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0)
      (0.0d0 0.0d0 0.0d0 1.0d0 0.0d0 0.0d0 0.0d0 0.0d0)
      (0.0d0 0.0d0 0.0d0 0.0d0 1.0d0 0.0d0 0.0d0 0.0d0)
      (0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 1.0d0 0.0d0 0.0d0)
      (0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 1.0d0)
      (0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 1.0d0 0.0d0))
  0 4 3)
 (GATE #2A((0 1) (1 0)) 4)
 (GATE #2A((1 0 0 0) (0 1 0 0) (0 0 0 1) (0 0 1 0)) 4 3)
 (GATE
  #2A((1.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0)
      (0.0d0 1.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0)
      (0.0d0 0.0d0 1.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0)
      (0.0d0 0.0d0 0.0d0 1.0d0 0.0d0 0.0d0 0.0d0 0.0d0)
      (0.0d0 0.0d0 0.0d0 0.0d0 1.0d0 0.0d0 0.0d0 0.0d0)
      (0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 1.0d0 0.0d0 0.0d0)
      (0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 1.0d0)
      (0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 1.0d0 0.0d0))
  0 3 4)
 (GATE #2A((1 0 0 0) (0 1 0 0) (0 0 0 1) (0 0 1 0)) 4 3)
 (GATE #2A((1 0 0 0) (0 0 1 0) (0 1 0 0) (0 0 0 1)) 0 2)
 (GATE #2A((0.70710677 0.70710677) (0.70710677 -0.70710677)) 0)
 (GATE
  #2A((1 0 0 0)
      (0 1 0 0)
      (0 0 1 0)
      (0 0 0 #C(0.7071067811865476d0 -0.7071067811865475d0)))
  0 1)
 (GATE #2A((0.70710677 0.70710677) (0.70710677 -0.70710677)) 1)
 (GATE
  #2A((1 0 0 0)
      (0 1 0 0)
      (0 0 1 0)
      (0 0 0 #C(0.9238795325112867d0 -0.3826834323650898d0)))
  0 2)
 (GATE
  #2A((1 0 0 0)
      (0 1 0 0)
      (0 0 1 0)
      (0 0 0 #C(0.7071067811865476d0 -0.7071067811865475d0)))
  1 2)
 (GATE #2A((0.70710677 0.70710677) (0.70710677 -0.70710677)) 2))
#+end_example

#+begin_src lisp :tangle yes
  (clq (shor-21 3 2)
       (make-machine :quantum-state (make-quantum-state 5)
                     :measurement-register 0))
#+end_src

#+RESULTS:
#+begin_example
#S(MACHINE
   :QUANTUM-STATE #(#C(0.12499998716429726d0 0.0d0)
                    #C(0.1154849297052678d0 -0.047835424133625445d0)
                    #C(0.088388338572106d0 -0.08838833857210598d0)
                    #C(0.047835424133625445d0 -0.1154849297052678d0)
                    #C(-0.12499998716429726d0 0.0d0)
                    #C(-0.1154849297052678d0 0.047835424133625445d0)
                    #C(-0.088388338572106d0 0.08838833857210598d0)
                    #C(-0.047835424133625445d0 0.1154849297052678d0)
                    #C(0.24999997432859453d0 0.0d0)
                    #C(0.07716456303067182d0 0.1154849297052678d0)
                    #C(0.036611648592191265d0 0.08838833857210598d0)
                    #C(0.07716456303067185d0 -0.1154849297052678d0)
                    #C(0.0d0 0.0d0)
                    #C(0.1728354112979227d0 -0.1154849297052678d0)
                    #C(0.21338832573640326d0 -0.08838833857210598d0)
                    #C(0.17283541129792268d0 0.1154849297052678d0)
                    #C(0.12499998716429726d0 0.0d0)
                    #C(-0.088388338572106d0 0.088388338572106d0)
                    #C(-0.12499998716429726d0 0.0d0)
                    #C(0.088388338572106d0 -0.088388338572106d0)
                    #C(0.12499998716429726d0 0.0d0)
                    #C(-0.088388338572106d0 0.088388338572106d0)
                    #C(-0.12499998716429726d0 0.0d0)
                    #C(0.088388338572106d0 -0.088388338572106d0)
                    #C(0.49999994865718905d0 0.0d0)
                    #C(-0.10426115416383362d0 -0.15603784414374836d0)
                    #C(0.0d0 0.0d0)
                    #C(-0.21338832573640326d0 0.3193581979826416d0)
                    #C(0.0d0 0.0d0)
                    #C(0.031037856979451092d0 -0.02073883300046364d0)
                    #C(0.0d0 0.0d0)
                    #C(-0.21338832573640326d0 -0.14258152083842962d0))
   :MEASUREMENT-REGISTER 0)
#+end_example

#+begin_src lisp :tangle yes
  (defun sample-final-state (state)
    (let ((rnd (random 1.0d0))
          (cumulative-prob 0.0d0))
      (dotimes (i (length state))
        (setf cumulative-prob (+ cumulative-prob (expt (abs (aref state i)) 2)))
        (when (>= cumulative-prob rnd)
          (return i)))))

  (defun counts (realizations qubits)
    (let* ((hilbert (expt 2 qubits))
           (results (make-array hilbert :initial-element 0)))
      (dotimes (i realizations results)
        (let ((machine (clq (shor-21 3 2)
                            (make-machine :quantum-state (make-quantum-state qubits)
                                          :measurement-register 0))))
          (let ((state (machine-quantum-state machine)))
            (let ((outcome (sample-final-state state)))
              (incf (aref results outcome))))))))
  (counts 100 5)
#+end_src

#+RESULTS:
| 0 | 4 | 0 | 0 | 1 | 1 | 4 | 1 | 6 | 1 | 0 | 1 | 0 | 6 | 5 | 7 | 2 | 0 | 1 | 0 | 1 | 3 | 4 | 1 | 23 | 3 | 0 | 20 | 0 | 0 | 0 | 5 |
